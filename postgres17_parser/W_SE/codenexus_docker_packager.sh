#!/bin/bash

# set -e: 脚本中任意命令执行失败则立即退出
# set -o pipefail: 管道中的任意命令失败，整个管道也视为失败
set -e
set -o pipefail

# --- 配置 ---
# 在生成的 start.sh 中使用的默认端口
DEFAULT_HTTP_PORT=7674
DEFAULT_BOLT_PORT=7689

# 等待容器启动的超时时间（秒）
WAIT_TIMEOUT=120

# --- 帮助函数 ---
function print_usage() {
    echo "Usage: $0 pack <running_container_name>"
    echo "   or: $0 unpack <package_file.tar.gz>"
    echo ""
    echo "Commands:"
    echo "  pack      Package a running container's bind-mounted data and generate a start script."
    echo "  unpack    Unpack a package and start the container."
    echo ""
    echo "Prerequisites: docker, jq, nc (netcat)"
}

function check_deps() {
    for cmd in docker jq nc; do
        if ! command -v $cmd &> /dev/null; then
            echo "Error: Required command '$cmd' not found."
            echo "Please install it and try again."
            exit 1
        fi
    done
}

# --- 主功能函数 ---

function pack_container() {
    local container_name=$1
    if [ -z "$container_name" ]; then
        echo "Error: Container name is required for 'pack' command."
        print_usage
        exit 1
    fi

    echo "--> 1. Verifying container '$container_name'..."
    if ! docker inspect "$container_name" &> /dev/null; then
        echo "Error: Container '$container_name' not found."
        exit 1
    fi
    
    local is_running=$(docker inspect --format='{{.State.Running}}' "$container_name")
    if [ "$is_running" != "true" ]; then
        echo "Error: Container '$container_name' is not running."
        exit 1
    fi

    echo "--> 2. Inspecting container and identifying bind mounts..."
    local temp_dir="package_temp_${container_name}"
    local data_dir="${temp_dir}/data_mounts"
    local package_file="${container_name}_package.tar.gz"

    # 清理旧的临时目录和包文件
    rm -rf "$temp_dir" "$package_file"
    mkdir -p "$data_dir"

    # 使用 jq 提取 bind mounts
    local mounts_json=$(docker inspect "$container_name" | jq -c '.[] | .Mounts | map(select(.Type == "bind"))')
    
    # 存储挂载点信息以供后续生成脚本使用
    declare -a mount_args
    
    echo "Found bind mounts:"
    echo "$mounts_json" | jq -r '.[] | "  - Host: \(.Source)\n    Container: \(.Destination)"'

    echo "--> 3. Copying data from mount points..."
    for row in $(echo "${mounts_json}" | jq -r '.[] | @base64'); do
        _jq() {
            echo "${row}" | base64 --decode | jq -r "${1}"
        }
        
        local source_path=$(_jq '.Source')
        local dest_path=$(_jq '.Destination')
        
        # 从容器路径创建目标目录名，移除前导斜杠
        local target_dir_name=$(basename "$dest_path")
        
        echo "    Copying from '$source_path' to '$data_dir/$target_dir_name'..."
        # 确保目标子目录存在
        mkdir -p "$data_dir/$target_dir_name"
        # 使用 rsync 复制，源路径后加 / 表示复制目录内容
        rsync -a "$source_path/" "$data_dir/$target_dir_name/"

        # 准备 docker run 的 -v 参数
        mount_args+=("-v \"\$(pwd)/data_mounts/${target_dir_name}\":${dest_path}")
    done
    
    echo "--> 4. Generating start.sh script..."
    
    # 获取镜像和环境变量
    local image_name=$(docker inspect "$container_name" | jq -r '.[0].Config.Image')
    local env_vars_json=$(docker inspect "$container_name" | jq -r '.[0].Config.Env[]')
    
    local start_script_path="${temp_dir}/start.sh"
    
    # 使用 heredoc 生成启动脚本
    cat > "$start_script_path" <<EOF
#!/bin/bash
set -e

# This script was auto-generated by docker_packager.sh

CONTAINER_NAME="${container_name}"
IMAGE_NAME="${image_name}"

echo "==> Stopping and removing existing container named '\$CONTAINER_NAME'..."
docker stop "\$CONTAINER_NAME" >/dev/null 2>&1 || true
docker rm "\$CONTAINER_NAME" >/dev/null 2>&1 || true

echo "==> Starting new container '\$CONTAINER_NAME'..."

docker run -d --name "\${CONTAINER_NAME}" \\
    -p "${DEFAULT_HTTP_PORT}":7474 \\
    -p "${DEFAULT_BOLT_PORT}":7687 \\
EOF

    # 添加挂载点参数
    for arg in "${mount_args[@]}"; do
        echo "    $arg \\" >> "$start_script_path"
    done

    # 添加环境变量参数
    while IFS= read -r env_var; do
        # 增加一个判断，防止空的 env_vars_json 导致 " -e "" \" 被添加
        if [ -n "$env_var" ]; then
            echo "    -e \"$env_var\" \\" >> "$start_script_path"
        fi
    done <<< "$env_vars_json"

    # ======================= FINAL FIX START =======================
    # 最终修正：
    # 使用 sed 将文件最后一行的末尾反斜杠 `\` 替换为镜像名称。
    # 这样可以确保镜像是 docker run 命令的最后一个参数，并且在同一行。
    #   $: 定位到最后一行
    #   s/\\$ /.../: 替换行尾的 `\` 字符
    #   \\$: 匹配一个字面的 `\` 字符在行尾 ($)
    #   \${IMAGE_NAME}: 替换成的内容
    sed -i '$ s/\\$/    \${IMAGE_NAME}/' "$start_script_path"
    # ======================= FINAL FIX END =========================

    cat >> "$start_script_path" <<EOF

echo "" # Add a newline for better formatting after docker run
echo "==> Container '\$CONTAINER_NAME' started in detached mode."
echo "    HTTP Port (host): ${DEFAULT_HTTP_PORT}"
echo "    Bolt Port (host): ${DEFAULT_BOLT_PORT}"
EOF

    chmod +x "$start_script_path"
    echo "    start.sh generated successfully."

    echo "--> 5. Creating package file '$package_file'..."
    (cd "$temp_dir" && tar -czf "../$package_file" .)
    
    echo "--> 6. Cleaning up temporary files..."
    rm -rf "$temp_dir"
    
    echo ""
    echo "======================================================"
    echo "  Package created successfully: $package_file"
    echo "======================================================"
}

function unpack_and_run() {
    local package_file=$1
    if [ -z "$package_file" ]; then
        echo "Error: Package file is required for 'unpack' command."
        print_usage
        exit 1
    fi

    if [ ! -f "$package_file" ]; then
        echo "Error: Package file '$package_file' not found."
        exit 1
    fi

    local deploy_dir="${package_file%.tar.gz}_deploy"
    
    echo "--> 1. Creating deployment directory '$deploy_dir'..."
    rm -rf "$deploy_dir"
    mkdir -p "$deploy_dir"

    echo "--> 2. Unpacking '$package_file'..."
    tar -xzf "$package_file" -C "$deploy_dir"
    
    local start_script_path="${deploy_dir}/start.sh"
    if [ ! -f "$start_script_path" ]; then
        echo "Error: 'start.sh' not found in the package."
        exit 1
    fi
    
    echo "--> 3. Executing start.sh to launch the container..."
    (cd "$deploy_dir" && ./start.sh)

    echo "--> 4. Waiting for container to be ready (checking port ${DEFAULT_HTTP_PORT})..."
    local start_time=$(date +%s)
    while true; do
        # 使用 nc 检查端口。-z: 只扫描不发送数据, -w 1: 1秒超时
        if nc -z localhost ${DEFAULT_HTTP_PORT} 2>/dev/null; then
            echo ""
            echo "Container is up and running! Port ${DEFAULT_HTTP_PORT} is accessible."
            break
        fi
        
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        if [ $elapsed -ge $WAIT_TIMEOUT ]; then
            echo ""
            echo "Error: Timeout of ${WAIT_TIMEOUT}s reached. Container failed to start or port is not accessible."
            echo "Please check container logs using: docker logs $(basename "$deploy_dir" _deploy)"
            exit 1
        fi
        
        echo -n "."
        sleep 2
    done
    
    echo ""
    echo "======================================================"
    echo "  Deployment completed successfully!"
    echo "  Data and start script are in: $deploy_dir"
    echo "======================================================"
}


# --- 脚本主入口 ---
if [ "$#" -eq 0 ]; then
    print_usage
    exit 1
fi

check_deps

COMMAND=$1
shift

case "$COMMAND" in
    pack)
        pack_container "$@"
        ;;
    unpack)
        unpack_and_run "$@"
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'"
        print_usage
        exit 1
        ;;
esac

exit 0